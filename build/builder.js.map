{"version":3,"sources":["../src/builder.ts"],"names":[],"mappings":"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","file":"builder.js","sourcesContent":["import * as Promise from 'bluebird'\nimport * as Dockerode from 'dockerode'\nimport * as _ from 'lodash'\nimport * as fs from 'mz/fs'\nimport * as path from 'path'\n\n// Type-less imports\nconst tar = require('tar-stream')\nconst duplexify = require('duplexify')\n// Following types are available, but do not work...\nconst es = require('event-stream')\nconst JSONStream = require('JSONStream')\n\n// Import hook definitions\nimport * as Plugin from './plugin'\nimport * as Utils from './utils'\n\nPromise.promisifyAll(Dockerode)\nPromise.promisifyAll(tar)\n\n/**\n * This class is responsible for interfacing with the docker daemon to\n * start and monitor a build. Most use cases will require a call to\n * registerHooks(...) and a call to createBuildStream(...). Everything\n * else can be done with the hook architecture.\n *\n */\nexport default class Builder {\n\n\tprivate docker: Dockerode\n\tprivate layers: string[]\n\n\t// Promisified types\n\tprivate dockerAsync: any\n\tprivate readdirBluebird = Promise.promisify(fs.readdir)\n\n\t/**\n\t * Initialise the builder class, with a pointer to the docker socket.\n\t *\n\t * Example:\n\t * new Builder({ socketPath: '/var/run/docker.sock' })\n\t */\n\tconstructor(dockerOpts: Dockerode.DockerOptions) {\n\t\tthis.docker = new Dockerode(dockerOpts)\n\n\t\tthis.dockerAsync = Promise.promisifyAll(this.docker)\n\t}\n\n\t/**\n\t * Start a build with the docker daemon, and return the stream to the caller.\n\t * The stream can be written to, and the docker daemon will interpret that\n\t * as a tar archive to build. The stream can also be read from, and the data\n\t * returned will be the output of the docker daemon build.\n\t *\n\t * @returns {NodeJS.ReadWriteStream}\n\t *\tA promise which resolves with a bi-directional stream, which is connected\n\t *\tto the docker daemon.\n\t */\n\tpublic createBuildStream(buildOpts: Object, hooks: Plugin.BuildHooks = {}): NodeJS.ReadWriteStream {\n\n\t\tconst self = this\n\n\t\tthis.layers = []\n\n\t\t// Create a stream to be passed into the docker daemon\n\t\tconst inputStream = es.through()\n\n\t\t// Create a bi-directional stream\n\t\tconst dup = duplexify()\n\n\t\t// Connect the input stream to the rw stream\n\t\tdup.setWritable(inputStream)\n\n\t\tthis.dockerAsync.buildImageAsync(inputStream, buildOpts)\n\t\t.then((res: NodeJS.ReadWriteStream) => {\n\n\t\t\tconst outputStream = res\n\t\t\t// parse the json objects\n\t\t\t.pipe(JSONStream.parse())\n\t\t\t// Don't use fat-arrow syntax here, to capture 'this' from es\n\t\t\t.pipe(es.through(function(data: any): void {\n\t\t\t\tif (data == null) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (data.error) {\n\t\t\t\t\tdup.destroy(new Error(data.error))\n\t\t\t\t} else {\n\t\t\t\t\t// Store image layers, so that they can be deleted by the caller\n\t\t\t\t\t// if necessary\n\t\t\t\t\tlet sha = Utils.extractLayer(data.stream)\n\t\t\t\t\tif (sha !== undefined) {\n\t\t\t\t\t\tself.layers.push(sha)\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.emit('data', data.stream)\n\t\t\t\t}\n\t\t\t}))\n\n\t\t\t// Catch any errors the stream produces\n\t\t\toutputStream.on('error', (err: Error) => {\n\t\t\t\tself.callHook(hooks, 'buildFailure', err)\n\t\t\t})\n\t\t\tdup.on('error', (err: Error) => {\n\t\t\t\tself.callHook(hooks, 'buildFailure', err)\n\t\t\t})\n\n\t\t\t// Setup the buildSuccess hook. This handler is not called on\n\t\t\t// error so we can use it to propagate the success information\n\t\t\toutputStream.on('end', () => {\n\t\t\t\tthis.callHook(hooks, 'buildSuccess', _.last(this.layers), this.layers)\n\t\t\t})\n\t\t\t// Connect the output of the docker daemon to the duplex stream\n\t\t\tdup.setReadable(outputStream)\n\n\t\t})\n\t\t.catch((err: Error) => {\n\t\t\t// Call the plugin's error handler\n\t\t\tself.callHook(hooks, 'buildFailure', err)\n\t\t})\n\n\t\t// Call the correct hook with the build stream\n\t\tthis.callHook(hooks, 'buildStream', dup)\n\t\t// and also return it\n\t\treturn dup\n\t}\n\n\t/**\n\t * Given a path, this function will create a tar stream containing all of the files,\n\t * and stream it to the docker daemon. It will then return a stream connected to\n\t * the output of the docker daemon.\n\t *\n\t * @param {string} dirPath\n\t *\tThe directory path to send to the docker daemon.\n\t *\n\t * @param {Object} buildOpts\n\t *\tBuild options to pass to the docker daemon.\n\t *\n\t * @returns {Promise<NodeJS.ReadableStream>}\n\t *\tA stream which is connected to the output of the docker daemon\n\t */\n\tpublic buildDir(dirPath: string, buildOpts: Object, hooks: Plugin.BuildHooks): Promise<NodeJS.ReadableStream> {\n\t\tconst pack = tar.pack()\n\n\t\treturn this.readdirBluebird(dirPath)\n\t\t\t.map((file: string) => {\n\t\t\t\tconst relPath = path.join(dirPath, file)\n\t\t\t\treturn Promise.all([file, fs.stat(relPath), fs.readFile(relPath)])\n\t\t\t})\n\t\t\t.map((fileInfo: [string, fs.Stats, Buffer]) => {\n\t\t\t\treturn pack.entryAsync({ name: fileInfo[0], size: fileInfo[1].size }, fileInfo[2])\n\t\t\t})\n\t\t\t.then(() => {\n\t\t\t\t// Tell the tar stream we're done\n\t\t\t\tpack.finalize()\n\t\t\t\t// Create a build stream to send the data to\n\t\t\t\tlet stream = this.createBuildStream(buildOpts, hooks)\n\n\t\t\t\t// Transform the stream if necessary\n\t\t\t\tstream = this.callHook(hooks, 'buildTransform', stream) || stream\n\n\t\t\t\t// Write the tar archive to the stream\n\t\t\t\tpack.pipe(stream)\n\t\t\t\t// ...and return it for reading\n\t\t\t\treturn stream\n\t\t\t})\n\t}\n\n\t/**\n\t * Internal function to call a hook, if it has been registered for the build.\n\t *\n\t * @param {string} name\n\t *\tThe name of the hook to be called.\n\t *\n\t * @param {any[]} args\n\t *\tThe arguments to pass to the hook. The values will be unwrapped before\n\t *\tbeing passed to the callback.\n\t *\n\t * @returns {any} The return value of the function, or nothing if the\n\t * function does not exist or does not provide a return value\n\t */\n\tprivate callHook(hooks: Plugin.BuildHooks, hook: Plugin.ValidHook, ...args: any[]): any {\n\t\tif (hook in hooks) {\n\t\t\t// Spread the arguments onto the callback function\n\t\t\tconst fn = hooks[hook]\n\t\t\tif (_.isFunction(fn)) {\n\t\t\t\treturn fn.apply(null, args)\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\n}\n\n"],"sourceRoot":"src"}