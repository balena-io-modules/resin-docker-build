{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":";;AAAA,oCAAmC;AACnC,6BAA4B;AAE5B;;;;;;;;;GASG;AACU,QAAA,YAAY,GAAG,CAAC,OAAe;IAC3C,MAAM,OAAO,GAAG,mBAAmB,CAAC,OAAO,CAAC,CAAA;IAC5C,EAAE,CAAC,CAAC,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC;QAC3B,MAAM,QAAQ,GAAG,0BAA0B,CAAA;QAC3C,MAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;QACpC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACX,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;QAChB,CAAC;IACF,CAAC;IAED,MAAM,CAAA;AACP,CAAC,CAAA;AAED,MAAM,mBAAmB,GAAG,CAAC,OAAe;IAC3C,MAAM,SAAS,GAAG,gBAAgB,CAAA;IAClC,MAAM,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;IACrC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;QACX,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;IAChB,CAAC;IAAC,IAAI,CAAC,CAAC;QACP,MAAM,CAAA;IACP,CAAC;AACF,CAAC,CAAA;AAED;;;GAGG;AACU,QAAA,gBAAgB,GAAG,CAAC,OAAe;IAC/C,MAAM,CAAC,IAAI,OAAO,CAAW,CAAC,OAAO,EAAE,MAAM;QAC5C,MAAM,KAAK,GAAa,EAAE,CAAA;QAE1B,qBAAqB;QACrB,IAAI,CAAC,OAAO,CAAC;aACZ,EAAE,CAAC,MAAM,EAAE,CAAC,IAAe;YAC3B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;gBAC/B,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;YACtB,CAAC;QACF,CAAC,CAAC;aACD,EAAE,CAAC,KAAK,EAAE;YACV,OAAO,CAAC,KAAK,CAAC,CAAA;QACf,CAAC,CAAC;aACD,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAA;IACrB,CAAC,CAAC,CAAA;AACH,CAAC,CAAA","file":"utils.js","sourcesContent":["import * as Promise from 'bluebird'\nimport * as klaw from 'klaw'\n\n/**\n * Given a docker 'arrow message' containing a sha representing\n * a layer, extract the sha digest. If the string passed in is not\n * an arrow message, undefined will be returned.\n *\n * @param {string} message\n *\tThe build message to parse\n * @returns {string}\n *\tEither the sha string, or undefined\n */\nexport const extractLayer = (message: string): string | undefined => {\n\tconst extract = extractArrowMessage(message)\n\tif (extract !== undefined) {\n\t\tconst shaRegex = /([a-f0-9]{12}[a-f0-9]*)/g\n\t\tconst match = shaRegex.exec(extract)\n\t\tif (match) {\n\t\t\treturn match[1]\n\t\t}\n\t}\n\n\treturn\n}\n\nconst extractArrowMessage = (message: string): string | undefined => {\n\tconst arrowTest = /^\\s*-+>\\s*(.+)/\n\tconst match = arrowTest.exec(message)\n\tif (match) {\n\t\treturn match[1]\n\t} else {\n\t\treturn\n\t}\n}\n\n/**\n * Go through an entire directory, splitting the entries out\n * into a list of paths to work through.\n */\nexport const directoryToFiles = (dirPath: string): Promise<string[]> => {\n\treturn new Promise<string[]>((resolve, reject) => {\n\t\tconst files: string[] = []\n\n\t\t// Walk the directory\n\t\tklaw(dirPath)\n\t\t.on('data', (item: klaw.Item) => {\n\t\t\tif (!item.stats.isDirectory()) {\n\t\t\t\tfiles.push(item.path)\n\t\t\t}\n\t\t})\n\t\t.on('end', () => {\n\t\t\tresolve(files)\n\t\t})\n\t\t.on('error', reject)\n\t})\n}\n"],"sourceRoot":"src"}